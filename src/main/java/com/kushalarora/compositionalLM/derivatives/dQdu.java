package com.kushalarora.compositionalLM.derivatives;

import com.google.common.base.Function;
import com.kushalarora.compositionalLM.model.CompositionalInsideOutsideScore;
import com.kushalarora.compositionalLM.model.Model;
import com.kushalarora.compositionalLM.optimizer.IIndexed;
import com.kushalarora.compositionalLM.options.Options;
import com.kushalarora.compositionalLM.utils.Parallelizer;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import org.apache.commons.math3.random.JDKRandomGenerator;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.factory.Nd4j;

import java.util.List;

import javax.annotation.Nullable;

/**
 * Created by karora on 6/21/15.
 * Energy function E is given as
 * E = g(u^Tp) where p is phrase vector..
 * dEdu = g'(u.t().dot(p))p
 * <p/>
 * dQdu = \sum{start}{end}{split} dEdu(start, end, split) * \mu(start, end, split)
 */
@Slf4j
public class dQdu<T extends List<? extends IIndexed>> extends AbstractBaseDerivativeClass implements IDerivative<T> {
    @Getter
    private INDArray dQdu;
    private int dimensions;
    private T data;
    private int length;
    private Options options;
    private Parallelizer parallelizer;


    public dQdu(int dim, T data, Options op) {
        super(new int[]{dim, 1});
        dQdu = Nd4j.zeros(dim, 1);
        dimensions = dim;
        this.data = data;
        length = data.size();
        options = op;
        parallelizer = new Parallelizer(op, op.grammarOp.maxLength/op.trainOp.blockNum + 1);
    }

    public dQdu(dQdu dqdu, T data, Options op) {
        super(dqdu.dQdu.shape());
        dQdu = dqdu.dQdu.dup();
        dimensions = dqdu.dQdu.shape()[0];
        this.data = data;
        length = data.size();
        options = op;
        parallelizer = new Parallelizer(op, op.grammarOp.maxLength/op.trainOp.blockNum + 1);
    }

    private dQdu(INDArray dqdu, T data, Options op) {
        super(dqdu.shape());
        this.dQdu = dqdu;
        dimensions = dqdu.shape()[0];
        this.data = data;
        length = data.size();
        options = op;
        parallelizer = new Parallelizer(op, op.grammarOp.maxLength/op.trainOp.blockNum + 1);
    }

    public void clear() {
        // Wipe clean
        for (int i = 0; i < dimensions; i++) {
            dQdu.putScalar(i, 0);
        }
    }

    public void add(IDerivative other) {
        dQdu = dQdu.add(((dQdu) other).getDQdu());
    }

    public void mul(double learningRate) {
        dQdu = dQdu.mul(learningRate);
    }

    public boolean containsNanOrInf() {
        return containsNanOrInf(dQdu);
    }

    public IDerivative adaGrad(IDerivative gradient) {
        return new dQdu(adaGrad.getGradient(((dQdu) gradient).dQdu), data, options);
    }

    public double norm()
    {
        return Nd4j.norm2(dQdu).sum(Integer.MAX_VALUE).getFloat(0);
    }

    public void calcDerivative(final Model model, final CompositionalInsideOutsideScore scorer) {
        final INDArray[][][] compositionMatrix = scorer.getCompositionMatrix();
        final INDArray[][] phraseMatrix = scorer.getPhraseMatrix();
        final double[][][] compositionMu = scorer.getMuScore();
        final double[][] compositionalIScore = scorer.getInsideSpanProb();


        Function<Integer, Void> unaryFunc = new Function<Integer, Void>()
        {
            public Void apply(Integer start)
            {
                int end = start + 1;
                int split = start;

                // For leaf nodes we consider the phrase
                INDArray phraseVector = phraseMatrix[start][end];

                // dE = g'(u.t().dot(p))
                double dE = model.energyDerivative(phraseVector);

                // dEdu = dE * p = g'(u.t().dot(p)) * p
                INDArray dEdu = phraseVector.muli(dE);
                synchronized (dQdu)
                {
                    // dQdu += dEdu * \mu[start][end][split]
                    dQdu = dQdu.add(
                            dEdu.muli(
                                    compositionMu[start][end][split]));
                }
                return null;
            }
        };

        if (options.trainOp.parallel) {
            parallelizer.parallelizer(0, length, unaryFunc);
        } else
        {
            // do leaf nodes
            for (int start = 0; start < length; start++)
            {
                unaryFunc.apply(start);
            }
        }



        for (int diff = 2; diff <= length; diff++) {
            final int diffFinal = diff;
            Function<Integer, Void> binaryFunc = new Function<Integer, Void>()
            {
                @Nullable
                public Void apply(Integer start)
                {
                    int end = start + diffFinal;
                    for (int split = start + 1; split < end; split++) {

                        // Composition vector is parent's(start, end) embedding generated by
                        // child1 (start, split) and child2 (split, end)
                        INDArray compositionVector = compositionMatrix[start][end][split];

                        // dE = g'(u.t().dot(p))
                        double dE = model.energyDerivative(compositionVector);

                        // dEdu = dE * p = g'(u.t().dot(p)) * p
                        INDArray dEdu = compositionVector.muli(dE);
                        synchronized (dQdu)
                        {
                            // dQdu += dEdu * \mu[start][end][split]
                            dQdu = dQdu.add(
                                    dEdu.muli(
                                            compositionMu[start][end][split]));
                        }
                    }
                    return null;
                }
            };

            if (options.trainOp.parallel) {
                parallelizer.parallelizer(0, length - diff, binaryFunc);
            }
            for (int start = 0; start + diff < length; start++) {
                binaryFunc.apply(start);
            }
        }

        if (compositionalIScore[0][length] == 0) {
            throw new RuntimeException("Z is zero for sentence " + data);
        }

        dQdu = dQdu.div(compositionalIScore[0][length]);

        if (containsNanOrInf()) {
            log.error("dQdu contains Nan Or Inf. for data {}", data);
            dQdu = Nd4j.rand(dimensions, 1, -1, 1, new JDKRandomGenerator());
            dQdu = dQdu.div(Nd4j.norm2(dQdu));
        }
    }
}
